<!DOCTYPE html>
<html lang="vi">
<head>
    <title>Nghêu Thần Thú - AR Maze</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin:0; overflow:hidden; font-family:Arial; }

        #instructions, #timer {
            position:absolute;
            left:50%;
            transform:translateX(-50%);
            color:white;
            background:rgba(0,0,0,0.6);
            padding:8px 16px;
            border-radius:20px;
            z-index:10;
        }
        #instructions { top:20px; }
        #timer { top:65px; }

        #overlay {
            position:absolute;
            bottom:20px;
            width:100%;
            text-align:center;
            display:none;
            z-index:10;
        }
        .btn {
            padding:14px 28px;
            font-size:18px;
            border:none;
            border-radius:50px;
            background:rgba(255,255,255,0.85);
        }
    </style>
</head>
<body>

<div id="instructions">Rà camera xuống đất và chạm để đặt mê cung</div>
<div id="timer">⏱ 0.0s</div>

<div id="overlay">
    <button class="btn" id="btnLeft">⬅️</button>
    <button class="btn" id="btnGo">⬆️</button>
    <button class="btn" id="btnRight">➡️</button>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

let scene, camera, renderer, controller, reticle;
let hitTestSource=null, hitTestRequested=false;

let mazeGroup, player, keyItem, gate;
let walls=[];

let gameStarted=false, hasKey=false, gameEnded=false;
let moveForward=false, rotateLeft=false, rotateRight=false;
let startTime=0;

// ===== MAZE MAP =====
const mazeMap=[
 [1,1,1,1,1,1,1],
 [1,0,0,0,0,0,1],
 [1,0,1,1,1,0,1],
 [1,0,1,0,1,0,1],
 [1,0,1,0,0,0,1],
 [1,0,0,0,1,0,1],
 [1,1,1,1,1,1,1],
];

const CELL_SIZE=0.25;

init();
animate();

function init(){
    scene=new THREE.Scene();
    camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.01,20);

    scene.add(new THREE.HemisphereLight(0xffffff,0xbbbbff,1));

    renderer=new THREE.WebGLRenderer({alpha:true,antialias:true});
    renderer.setSize(innerWidth,innerHeight);
    renderer.xr.enabled=true;
    document.body.appendChild(renderer.domElement);

    document.body.appendChild(ARButton.createButton(renderer,{requiredFeatures:['hit-test']}));

    controller=renderer.xr.getController(0);
    controller.addEventListener('select',onSelect);
    scene.add(controller);

    reticle=new THREE.Mesh(
        new THREE.RingGeometry(0.12,0.16,32).rotateX(-Math.PI/2),
        new THREE.MeshBasicMaterial({color:0x00ff00})
    );
    reticle.matrixAutoUpdate=false;
    reticle.visible=false;
    scene.add(reticle);

    setupUI();
}

function setupUI(){
    btnGo.ontouchstart=()=>moveForward=true;
    btnGo.ontouchend=()=>moveForward=false;
    btnLeft.ontouchstart=()=>rotateLeft=true;
    btnLeft.ontouchend=()=>rotateLeft=false;
    btnRight.ontouchstart=()=>rotateRight=true;
    btnRight.ontouchend=()=>rotateRight=false;
}

function onSelect(){
    if(reticle.visible && !gameStarted) spawnGame(reticle.matrix);
}

function spawnGame(matrix){
    gameStarted=true;
    gameEnded=false;
    hasKey=false;
    startTime=performance.now();

    document.getElementById('overlay').style.display='block';
    document.getElementById('instructions').innerText='Tìm chìa khóa để mở cổng';

    mazeGroup=new THREE.Group();
    mazeGroup.position.setFromMatrixPosition(matrix);
    scene.add(mazeGroup);

    mazeGroup.add(new THREE.Mesh(
        new THREE.BoxGeometry(2,0.05,2),
        new THREE.MeshPhongMaterial({color:0x808080})
    ));

    createMazeWalls();

    player=new THREE.Mesh(
        new THREE.SphereGeometry(0.05),
        new THREE.MeshPhongMaterial({color:0xff0000})
    );
    player.position.set(0,0.15,0.8);
    mazeGroup.add(player);

    player.add(new THREE.ArrowHelper(
        new THREE.Vector3(0,0,-1),
        new THREE.Vector3(0,0.1,0),
        0.18,0xffaa00
    ));

    keyItem=new THREE.Mesh(
        new THREE.SphereGeometry(0.06),
        new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xffcc00})
    );
    keyItem.position.set(0.5,0.2,-0.5);
    mazeGroup.add(keyItem);

    gate=new THREE.Mesh(
        new THREE.BoxGeometry(0.25,0.4,0.08),
        new THREE.MeshPhongMaterial({color:0x0000ff})
    );
    gate.position.set(-0.5,0.2,-0.8);
    mazeGroup.add(gate);
}

function createMazeWalls(){
    walls=[];
    const geo=new THREE.BoxGeometry(CELL_SIZE,0.3,CELL_SIZE);
    const mat=new THREE.MeshPhongMaterial({color:0x555555});

    for(let z=0;z<mazeMap.length;z++){
        for(let x=0;x<mazeMap[z].length;x++){
            if(mazeMap[z][x]){
                const w=new THREE.Mesh(geo,mat);
                w.position.set((x-3)*CELL_SIZE,0.15,(z-3)*CELL_SIZE);
                mazeGroup.add(w);
                walls.push(w);
            }
        }
    }
}

function checkCollision(nextPos){
    const box=new THREE.Box3().setFromCenterAndSize(
        nextPos,new THREE.Vector3(0.1,0.1,0.1)
    );
    for(const w of walls){
        if(box.intersectsBox(new THREE.Box3().setFromObject(w))) return true;
    }
    return false;
}

function updateGame(){
    if(!gameStarted||gameEnded) return;

    const speed=0.012, rot=0.05;

    if(rotateLeft) player.rotation.y+=rot;
    if(rotateRight) player.rotation.y-=rot;

    if(moveForward){
        const dir=new THREE.Vector3();
        player.getWorldDirection(dir);
        const next=player.position.clone().add(dir.multiplyScalar(speed));
        if(!checkCollision(next)) player.position.copy(next);
    }

    if(!hasKey){
        keyItem.position.y=0.2+Math.sin(performance.now()*0.004)*0.04;
        if(player.position.distanceTo(keyItem.position)<0.15){
            hasKey=true;
            keyItem.visible=false;
            instructions.innerText='Đã có chìa khóa!';
        }
    }

    if(hasKey && player.position.distanceTo(gate.position)<0.2){
        gameEnded=true;
        instructions.innerText=`CHIẾN THẮNG! ${(performance.now()-startTime)/1000}s`;
    }

    timer.innerText=`⏱ ${((performance.now()-startTime)/1000).toFixed(1)}s`;
}

function animate(){
    renderer.setAnimationLoop(render);
}

function render(_,frame){
    if(frame){
        const session=renderer.xr.getSession();
        const ref=renderer.xr.getReferenceSpace();

        if(!hitTestRequested){
            session.requestReferenceSpace('viewer').then(s=>{
                session.requestHitTestSource({space:s}).then(src=>hitTestSource=src);
            });
            hitTestRequested=true;
        }

        if(hitTestSource){
            const hits=frame.getHitTestResults(hitTestSource);
            if(hits.length){
                reticle.visible=true;
                reticle.matrix.fromArray(hits[0].getPose(ref).transform.matrix);
            }
        }
    }
    updateGame();
    renderer.render(scene,camera);
}
</script>
</body>
</html>
