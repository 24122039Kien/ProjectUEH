<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0"/>
<title>Hành Trình Linh Nghê - Final Color</title>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<style>
  body { margin:0; overflow:hidden; font-family: sans-serif; user-select: none; -webkit-user-select: none; }
  
  /* UI CSS */
  #introScreen {
    position: fixed; inset: 0;
    background-image: url('Background.png'); 
    background-size: cover; background-position: center;
    background-color: #ffeaa7;
    display:flex; flex-direction:column;
    justify-content:center; align-items:center;
    z-index: 100;
  }
  
  #startARBtn {
    /* 1. VỊ TRÍ: Giảm số này để đưa nút LÊN CAO che chữ "Bắt đầu" gốc */
    /* Code cũ là 150px, hãy thử giảm xuống khoảng 70px - 90px */
    margin-top: 30px; 
    
    /* 2. MÀU SẮC: Đổi thành màu kem nhạt để trùng với nền ảnh */
    background: #FEF7E6; 
    
    /* Màu chữ: Dùng màu xanh cổ vịt đậm cho giống thiết kế */
    color: #0E5C6C; 

    /* 3. THẨM MỸ: Bỏ viền và bóng để nút trông như một phần của ảnh */
    border: none; 
    box-shadow: none;
    
    /* Các thông số kích thước giữ nguyên */
    padding: 15px 40px; 
    font-size: 22px; /* Tăng nhẹ cỡ chữ cho che hết chữ gốc */
    font-weight: 900; /* Chữ đậm hơn */
    border-radius: 50px;
    cursor: pointer; z-index: 101; pointer-events: auto;
  }
  
  /* Hiệu ứng khi nhấn vào nút (làm mờ nhẹ để biết đã bấm) */
  #startARBtn:active { 
    transform: scale(0.95); 
    opacity: 0.8;
  }

  .iconBtn {
    position: fixed; width:60px; height:60px;
    background: transparent; border:none;
    background-size: contain; background-repeat:no-repeat; background-position:center;
    z-index: 102; cursor:pointer;
  }
  #volumeBtn { top:20px; right:20px; background-image:url('Volume_on.png'); }
  #helpBtn { bottom:20px; right:20px; background-image:url('Help.png'); }

  .overlay-screen {
    position: fixed; inset: 0; background: rgba(0,0,0,0.9);
    display:none; flex-direction: column; justify-content:center; align-items:center;
    z-index: 200;
  }
  .overlay-screen img { max-width: 90%; max-height: 60%; object-fit: contain; margin-bottom: 20px; }
  .active { display: flex !important; }

  .home-btn {
    padding: 12px 30px; font-size: 18px; font-weight: bold;
    background: #e74c3c; color: white;
    border: 2px solid white; border-radius: 30px;
    cursor: pointer;
  }

  #game-ui {
    position: fixed; 
    top: 15%; /* Cách đỉnh màn hình một chút để tránh logo (nếu có) */
    left: 0; 
    width: 100%; /* Chiếm hết chiều ngang để canh giữa chuẩn */
    text-align: center; /* Canh giữa chữ */
    
    /* Font chữ & Màu sắc */
    color: #ffaa00; /* Màu cam vàng giống trong hình */
    font-size: 28px; /* Chữ to hơn */
    font-weight: 900; /* Chữ siêu đậm */
    font-family: sans-serif; /* Hoặc font thư pháp nếu bạn có import */
    
    /* Tạo viền chữ (Stroke) màu nâu đỏ cho nổi bật */
    -webkit-text-stroke: 1px #5e3000; 
    text-shadow: 2px 2px 0px #5e3000;
    
    z-index: 90; 
    display: none; /* Mặc định ẩn, vào game mới hiện */
    pointer-events: none; /* Để bấm xuyên qua được */
  }
  
  #ar-guide {
    position: fixed; bottom: 50px; left:0; width:100%;
    text-align: center; color: yellow; font-size: 16px;
    text-shadow: 1px 1px 2px black; pointer-events: none;
    display: none; z-index: 999; font-weight: bold;
  }
  
  /* Bảng báo lỗi (Chỉ hiện khi code sập) */
  #error-console {
    position: fixed; top:0; left:0; width:100%; background:rgba(200,0,0,0.8);
    color:white; font-size:12px; pointer-events:none; z-index:99999; display:none;
  }
  /* Khung viền AR Overlay */
  #ar-overlay {
    position: fixed; 
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 80; /* Cao hơn game 3D nhưng thấp hơn các nút bấm */
    
    /* QUAN TRỌNG: Cho phép vuốt tay xuyên qua hình này để chơi game */
    pointer-events: none; 
    
    /* Thay tên file ảnh khung viền của bạn vào đây (phải là PNG nền trong suốt) */
    background-image: url('Frame.png'); 
    background-size: cover; 
    background-position: center;
    background-repeat: no-repeat;
    
    display: none; /* Mặc định ẩn, khi vào AR mới hiện */
  }
</style>
</head>

<body>

<div id="error-console"></div>
<div id="ar-guide">Quét sàn nhà để đặt Game...</div>
<div id="game-ui">Ngọc: 0 / 10</div>
<div id="ar-overlay"></div>

<div id="introScreen">
  <button id="startARBtn" onclick="startGame()">Bắt đầu AR</button>
</div>

<button id="volumeBtn" class="iconBtn" onclick="toggleMute()"></button>
<button id="helpBtn" class="iconBtn" onclick="showHelp()"></button>

<div id="ruleScreen" class="overlay-screen" onclick="nextSlide()">
  <img id="ruleImage" src="LoiNgo.png" />
</div>

<div id="winScreen" class="overlay-screen">
  <img src="Win.png" alt="Chiến Thắng" />
  <button class="home-btn" onclick="location.reload()">Về Màn Hình Chính</button>
</div>

<script>
// Biến cờ kiểm tra: false = Đang xem Help, true = Đang quy trình vào Game
let isGameMode = false;

// Bắt lỗi hệ thống
window.onerror = function(msg, url, line) {
    const div = document.getElementById('error-console');
    if(div) {
        div.style.display = 'block';
        div.innerText = "LỖI: " + msg + " (Dòng " + line + ")";
    }
};

const ruleScreen = document.getElementById('ruleScreen');
const ruleImage = document.getElementById('ruleImage');
const introScreen = document.getElementById('introScreen');

// 1. NÚT HELP: Chỉ hiện Lời Ngỏ
function showHelp() {
    isGameMode = false; // Đánh dấu: Chỉ xem chơi thôi
    ruleImage.src = "LoiNgo.png"; 
    ruleScreen.classList.add('active');
}

// 2. NÚT BẮT ĐẦU: Hiện Luật Chơi trước -> Rồi mới vào AR
function startGame() {
    bgMusic.play().catch(e=>{});
    
    // Ẩn màn hình intro
    introScreen.style.display = 'none';
    
    // Đánh dấu: Đang bắt đầu vào game
    isGameMode = true; 
    
    // Hiện ảnh Luật chơi
    ruleImage.src = "LuatChoi.png"; 
    ruleScreen.classList.add('active');
}

// 3. KHI NHẤN VÀO MÀN HÌNH (Để tắt bảng)
function nextSlide() {
    // Tắt bảng đi
    ruleScreen.classList.remove('active');

    // Kiểm tra xem nãy bấm nút nào?
    if (isGameMode === true) {
    // Nếu nãy bấm Bắt Đầu -> Giờ mới gọi WebAR
    if (window.initARSession) {
        window.initARSession();
    } else {
        alert("Lỗi: Module AR chưa tải xong!");
        introScreen.style.display = 'flex'; // Hiện lại intro nếu lỗi
    }
    isGameMode = false; // Reset trạng thái
    }
    // Nếu isGameMode là false (nãy bấm Help) thì tắt bảng là xong.
}

// LOGIC ÂM THANH (Giữ nguyên)
const bgMusic = new Audio("Audio.mp3");
bgMusic.loop = true;
let isMuted = false;

function toggleMute() {
    isMuted = !isMuted;
    bgMusic.muted = isMuted;
    document.getElementById('volumeBtn').style.opacity = isMuted ? "0.5" : "1";
    if(!isMuted) bgMusic.play().catch(e=>{});
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

let renderer, scene, camera;
let mazeGroup, player, reticle;
let hitTestSource = null, hitTestSourceRequested = false, isMazePlaced = false;

let grid = [], orbMeshes = [];
// --- CẤU HÌNH ---
const ROWS = 15, COLS = 15;
const TILE_SIZE = 0.08; 
const TOTAL_ORBS = 10; 
// ----------------

let moveState='IDLE';
let currentTile={r:1, c:1}, targetTile={r:1, c:1};
let currentDir={r:0, c:0}, nextDir={r:0, c:0};

window.initARSession = async function() {
    if (!navigator.xr) { alert("Thiết bị không hỗ trợ AR"); return; }
    try {
        const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['local', 'hit-test'] });
        setupThree(session);
    } catch (e) { alert("Lỗi mở AR: " + e.message); }
};

function setupThree(session) {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

    renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.xr.setSession(session);
    renderer.xr.setReferenceSpaceType('local');
    document.body.appendChild(renderer.domElement);

    // Hiện khung viền ngay lập tức khi Camera AR vừa bật lên
    document.getElementById('ar-overlay').style.display = 'block';

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5,10,5);
    scene.add(dirLight);

    reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    mazeGroup = new THREE.Group();
    mazeGroup.visible = false;
    scene.add(mazeGroup);

    // GỌI HÀM TẠO MÊ CUNG MỚI (Đã đồng bộ tên hàm)
    createMazeDFS(); 
    spawnOrbs();
    loadPlayer();

    session.addEventListener('select', onSelect);
    document.getElementById('ar-guide').style.display = 'block';
    renderer.setAnimationLoop(render);
    setupTouch();
}

function onSelect() {
    if (reticle.visible && !isMazePlaced) {
        mazeGroup.position.setFromMatrixPosition(reticle.matrix);
        mazeGroup.visible = true;
        isMazePlaced = true;
        reticle.visible = false;
        document.getElementById('ar-guide').style.display = 'none';
        document.getElementById('game-ui').style.display = 'block'; 
    }
}

function render(timestamp, frame) {
    if (frame) {
        if (!isMazePlaced) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();
            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then((refSpace) => {
                    session.requestHitTestSource({ space: refSpace }).then((source) => { hitTestSource = source; });
                });
                session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                hitTestSourceRequested = true;
            }
            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    reticle.visible = true;
                    reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    document.getElementById('ar-guide').innerText = "Chạm màn hình để đặt Game";
                } else {
                    reticle.visible = false;
                    document.getElementById('ar-guide').innerText = "Quét sàn nhà để đặt Game...";
                }
            }
        }
        if (isMazePlaced && player) {
            updatePlayerMovement();
            animateOrbs();
        }
    }
    renderer.render(scene, camera);
}

// === TẠO MÊ CUNG (Thuật toán DFS + Màu Mới) ===
function createMazeDFS() {
    // 1. ÁP DỤNG MÃ MÀU BẠN YÊU CẦU (Đã chuyển sang 0x)
    const wallColor = 0x5198A5; // Màu tường sáng
    const floorColor = 0x00598B; // Màu sàn đậm

    const fGeo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
    const fMat = new THREE.MeshBasicMaterial({color: floorColor, transparent:true, opacity:0.9});
    const wGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
    const wMat = new THREE.MeshStandardMaterial({color: wallColor});

    // Reset lưới
    grid = Array.from({length: ROWS}, () => Array(COLS).fill(1));

    // Đào đường
    const dirs = [[0,2], [0,-2], [2,0], [-2,0]]; 
    function carve(r, c) {
        grid[r][c] = 0;
        dirs.sort(() => Math.random() - 0.5);
        for (let [dr, dc] of dirs) {
            let nr = r + dr, nc = c + dc;
            if (nr > 0 && nr < ROWS-1 && nc > 0 && nc < COLS-1 && grid[nr][nc] === 1) {
                grid[r + dr/2][c + dc/2] = 0; 
                carve(nr, nc);
            }
        }
    }
    carve(1, 1);

    // Đục thêm lỗ ngẫu nhiên (để dễ chơi hơn)
    for(let i=0; i<15; i++){
        let r = Math.floor(Math.random()*(ROWS-2))+1;
        let c = Math.floor(Math.random()*(COLS-2))+1;
        grid[r][c] = 0;
    }

    // Vẽ 3D
    for(let r=0; r<ROWS; r++){
        for(let c=0; c<COLS; c++){
            let x = (c - COLS/2) * TILE_SIZE;
            let z = (r - ROWS/2) * TILE_SIZE;
            
            if(grid[r][c] === 1){ 
                let m = new THREE.Mesh(wGeo, wMat);
                m.position.set(x, TILE_SIZE/2, z); 
                mazeGroup.add(m);
            } else { 
                let f = new THREE.Mesh(fGeo, fMat);
                f.rotation.x = -Math.PI/2;
                f.position.set(x, 0.005, z);
                mazeGroup.add(f);
            }
        }
    }
}

function spawnOrbs() {
    const orbGeo = new THREE.SphereGeometry(TILE_SIZE * 0.25, 16, 16);
    const orbMat = new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0xaa6600});

    let count = 0;
    let attempts = 0;
    // Thêm break loop an toàn để tránh treo trình duyệt
    while(count < TOTAL_ORBS && attempts < 2000){
        attempts++;
        let r = Math.floor(Math.random() * (ROWS-2)) + 1;
        let c = Math.floor(Math.random() * (COLS-2)) + 1;
        
        if(grid[r][c] === 0 && !(r==1 && c==1)) {
            const exists = orbMeshes.find(o => o.userData.r === r && o.userData.c === c);
            if(!exists){
                let orb = new THREE.Mesh(orbGeo, orbMat);
                let x = (c - COLS/2) * TILE_SIZE;
                let z = (r - ROWS/2) * TILE_SIZE;
                orb.position.set(x, TILE_SIZE * 0.3, z);
                orb.userData = { r: r, c: c, active: true };
                mazeGroup.add(orb);
                orbMeshes.push(orb);
                count++;
            }
        }
    }
}

function animateOrbs() {
    const time = Date.now() * 0.002;
    orbMeshes.forEach(orb => {
        if(orb.userData.active) {
            orb.position.y = (TILE_SIZE * 0.3) + Math.sin(time) * 0.01;
            orb.rotation.y += 0.05;
        }
    });
}

function checkCollection() {
    orbMeshes.forEach(orb => {
        if (orb.userData.active && orb.userData.r === currentTile.r && orb.userData.c === currentTile.c) {
            orb.userData.active = false;
            orb.visible = false;
            let collected = orbMeshes.filter(o => !o.userData.active).length;
            document.getElementById('game-ui').innerText = `Ngọc: ${collected} / ${TOTAL_ORBS}`;
            
            if(collected >= TOTAL_ORBS) {
                setTimeout(() => {
                    document.getElementById('winScreen').classList.add('active');
                    document.getElementById('game-ui').style.display = 'none';
                    renderer.xr.getSession().end();
                }, 500);
            }
        }
    });
}

function loadPlayer() {
    const loader = new GLTFLoader();
    loader.load('model.glb', (gltf)=>{
        player = gltf.scene;
        // 3. ĐÃ TĂNG SIZE LINH VẬT LÊN 0.65
        const scale = TILE_SIZE * 0.7; 
        player.scale.set(scale, scale, scale); 
        mazeGroup.add(player);
        updatePlayerVisualPos();
    }, undefined, (e)=>{
        player = new THREE.Mesh(
            new THREE.BoxGeometry(TILE_SIZE*0.6, TILE_SIZE*0.6, TILE_SIZE*0.6), 
            new THREE.MeshStandardMaterial({color:'red'})
        );
        mazeGroup.add(player);
        updatePlayerVisualPos();
    });
}

function updatePlayerVisualPos(){
    if(!player) return;
    let x = (currentTile.c - COLS/2) * TILE_SIZE;
    let z = (currentTile.r - ROWS/2) * TILE_SIZE;
    player.position.set(x, 0, z);
}

function updatePlayerMovement() {
    if(moveState === 'MOVING') {
        let destX = (targetTile.c - COLS/2)*TILE_SIZE;
        let destZ = (targetTile.r - ROWS/2)*TILE_SIZE;
        let target = new THREE.Vector3(destX, 0, destZ);
        const speed = TILE_SIZE * 0.15; 

        if(player.position.distanceTo(target) < speed) {
            player.position.copy(target);
            currentTile = {...targetTile};
            moveState = 'IDLE';
            checkCollection();
        } else {
            let dir = new THREE.Vector3().subVectors(target, player.position).normalize();
            player.position.addScaledVector(dir, speed);
        }
    } else if(moveState === 'IDLE') {
        if(nextDir.r!==0 || nextDir.c!==0) {
           let nr = currentTile.r + nextDir.r;
           let nc = currentTile.c + nextDir.c;
           if(grid[nr] && grid[nr][nc] === 0) {
               targetTile = {r:nr, c:nc};
               moveState = 'MOVING';
               player.lookAt((nc-COLS/2)*TILE_SIZE, 0, (nr-ROWS/2)*TILE_SIZE);
           }
           nextDir={r:0,c:0};
        }
    }
}

function setupTouch() {
    let startX, startY;
    window.addEventListener('touchstart', e=>{
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });
    window.addEventListener('touchend', e=>{
        if(!isMazePlaced) return;
        let dx = e.changedTouches[0].clientX - startX;
        let dy = e.changedTouches[0].clientY - startY;
        if(Math.abs(dx) > Math.abs(dy)) nextDir = dx>0 ? {r:0,c:1} : {r:0,c:-1};
        else nextDir = dy>0 ? {r:1,c:0} : {r:-1,c:0};
    });
}
</script>
</body>
</html>
