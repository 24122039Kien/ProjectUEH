<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0"/>
<title>Hành Trình Linh Nghê - AR</title>

<style>
  body { margin:0; overflow:hidden; font-family: 'Arial', sans-serif; user-select: none; -webkit-user-select: none; }
  
  /* Màn hình Intro */
  #introScreen {
    position: fixed; inset: 0;
    /* Dùng màu nền dự phòng nếu ảnh lỗi */
    background: #FFEFBA; 
    background-image: url('Background.png'); 
    background-size: cover; background-position: center;
    display:flex; flex-direction:column;
    justify-content:center; align-items:center;
    z-index: 10000;
  }
  
  /* Logo/Tiêu đề */
  h1 {
    color: #d35400; text-shadow: 2px 2px 0px #fff;
    font-size: 40px; text-align: center; margin-bottom: 50px;
    font-weight: 900;
  }

  /* Nút Bắt đầu */
  #startARBtn {
    padding: 15px 40px; font-size: 20px; font-weight: bold;
    color: white; background: #009432;
    border: 3px solid white; border-radius: 50px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    cursor: pointer; transition: transform 0.1s;
  }
  #startARBtn:active { transform: scale(0.95); background: #006266; }

  /* UI Game (Ẩn lúc đầu) */
  .gameUI { display: none; }
  
  /* Nút điều hướng ảo (Dành cho PC test) */
  #dpad {
    position: fixed; bottom: 20px; right: 20px;
    display: grid; grid-template-columns: 50px 50px 50px; gap: 5px;
    z-index: 10001; opacity: 0.5;
  }
  .dbtn { width: 50px; height: 50px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 1px solid white; color: white; font-size: 20px; display: flex; justify-content: center; align-items: center;}

  /* Bảng hiện lỗi (QUAN TRỌNG ĐỂ DEBUG) */
  #errorConsole {
    position: fixed; top: 0; left: 0; width: 100%; height: auto;
    background: rgba(255, 0, 0, 0.8); color: white;
    font-size: 12px; padding: 5px; z-index: 99999;
    pointer-events: none; white-space: pre-wrap;
    display: none; /* Chỉ hiện khi có lỗi */
  }
</style>
</head>

<body>

<div id="errorConsole"></div>

<div id="introScreen">
  <h1>HÀNH TRÌNH<br>LINH NGHÊ</h1>
  <button id="startARBtn">BẮT ĐẦU AR</button>
  <p style="margin-top:20px; font-size:12px; color:#555;">v1.2 Fixed Logic</p>
</div>

<div id="dpad" class="gameUI">
    <div></div><div class="dbtn" id="btnUp">⬆️</div><div></div>
    <div class="dbtn" id="btnLeft">⬅️</div><div></div><div class="dbtn" id="btnRight">➡️</div>
    <div></div><div class="dbtn" id="btnDown">⬇️</div><div></div>
</div>

<script>
    // --- HỆ THỐNG BẮT LỖI (DEBUGGER) ---
    // Cái này sẽ in lỗi ra màn hình điện thoại để bạn biết tại sao nó đứng
    window.onerror = function(msg, url, line, col, error) {
        const consoleDiv = document.getElementById('errorConsole');
        consoleDiv.style.display = 'block';
        consoleDiv.innerHTML += `LỖI: ${msg} <br> (Dòng: ${line})<br>`;
        return false;
    };
    window.addEventListener('unhandledrejection', function(event) {
        const consoleDiv = document.getElementById('errorConsole');
        consoleDiv.style.display = 'block';
        consoleDiv.innerHTML += `LỖI ASYNC: ${event.reason}<br>`;
    });
</script>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

// --- CẤU HÌNH ---
const ROWS = 15, COLS = 15;
const TILE_SIZE = 0.2; // 20cm mỗi ô
const MOVE_SPEED = 1.5; // Tốc độ di chuyển (mét/giây)

// --- BIẾN TOÀN CỤC ---
let renderer, scene, camera;
let player, playerMixer;
let grid = [];
let mazeGroup; // Nhóm chứa toàn bộ mê cung để AR dễ quản lý
let isGameRunning = false;
let clock = new THREE.Clock();

// --- LOGIC PACMAN (TILE-TO-TILE) ---
// State: 'IDLE' (đứng yên giữa ô), 'MOVING' (đang trượt sang ô khác)
let moveState = 'IDLE'; 
let currentTile = { r: 1, c: 1 }; // Ô hiện tại
let targetTile = { r: 1, c: 1 };  // Ô đích đến
let currentDir = { r: 0, c: 0 };  // Hướng đang đi
let nextDir = { r: 0, c: 0 };     // Hướng dự định đi (Input buffer)

// --- KHỞI TẠO ---
const btnStart = document.getElementById('startARBtn');
btnStart.addEventListener('click', async () => {
    console.log("Nút Bắt đầu được nhấn");
    
    // 1. Ẩn Intro
    document.getElementById('introScreen').style.display = 'none';
    document.querySelectorAll('.gameUI').forEach(e => e.style.display = 'grid');

    // 2. Khởi tạo WebXR
    if (navigator.xr) {
        try {
            const session = await navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local', 'hit-test'] // Thêm local để ổn định
            });
            initThreeJS(session);
        } catch (e) {
            alert("Không thể mở AR: " + e.message);
            // Fallback: Chạy chế độ 3D thường để test nếu AR lỗi
            initThreeJS(null); 
        }
    } else {
        alert("Thiết bị không hỗ trợ WebXR. Chạy chế độ 3D thường.");
        initThreeJS(null);
    }
});

function initThreeJS(session) {
    scene = new THREE.Scene();

    // Camera
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    
    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    if (session) {
        renderer.xr.enabled = true;
        renderer.xr.setSession(session);
        renderer.xr.setReferenceSpaceType('local');
    } else {
        // Setup cho chế độ không AR (Test trên PC)
        camera.position.set(0, 3, 3);
        camera.lookAt(0, 0, 0);
        scene.background = new THREE.Color(0x333333);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
    }

    document.body.appendChild(renderer.domElement);

    // Ánh sáng
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    // Tạo Game World
    mazeGroup = new THREE.Group();
    // Đẩy mê cung ra phía trước mặt và thấp xuống (quan trọng cho AR)
    mazeGroup.position.set(0, -0.5, -1.5); 
    scene.add(mazeGroup);

    generateMazeData();
    buildMazeMesh(); // Xây tường
    createPlayer();  // Tạo nhân vật

    // Bắt sự kiện vuốt tay
    setupTouchControls();

    isGameRunning = true;
    renderer.setAnimationLoop(render);
}

// --- TẠO MÊ CUNG ---
function generateMazeData() {
    // 1: Tường, 0: Đường đi
    grid = Array.from({length: ROWS}, () => Array(COLS).fill(1));
    
    // Thuật toán đục tường cơ bản
    const carve = (r, c) => {
        grid[r][c] = 0;
        const dirs = [[0,2], [0,-2], [2,0], [-2,0]].sort(() => Math.random() - 0.5);
        for(let [dr, dc] of dirs) {
            const nr = r + dr, nc = c + dc;
            if(nr > 0 && nr < ROWS-1 && nc > 0 && nc < COLS-1 && grid[nr][nc] === 1) {
                grid[r + dr/2][c + dc/2] = 0;
                carve(nr, nc);
            }
        }
    }
    carve(1, 1);
    
    // Đục thêm lỗ ngẫu nhiên cho dễ đi
    for(let i=0; i<30; i++) {
        let r = Math.floor(Math.random()*(ROWS-2))+1;
        let c = Math.floor(Math.random()*(COLS-2))+1;
        grid[r][c] = 0;
    }
    
    // Đảm bảo vị trí xuất phát (1,1) luôn trống
    grid[1][1] = 0;
}

function buildMazeMesh() {
    const wallGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x8e44ad }); // Màu tím
    const floorGeo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
    const floorMat = new THREE.MeshBasicMaterial({ color: 0x222222 });

    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            const x = (c - COLS/2) * TILE_SIZE;
            const z = (r - ROWS/2) * TILE_SIZE;

            if (grid[r][c] === 1) {
                // Tạo Tường
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set(x, TILE_SIZE/2, z);
                mazeGroup.add(wall);
            } else {
                // Tạo Sàn (để dễ nhìn đường)
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI/2;
                floor.position.set(x, 0.01, z);
                mazeGroup.add(floor);
            }
        }
    }
}

// --- TẠO NHÂN VẬT ---
function createPlayer() {
    // Thử load file model.glb
    const loader = new GLTFLoader();
    loader.load(
        'model.glb', // Đảm bảo file này nằm cùng thư mục với index.html
        (gltf) => {
            player = gltf.scene;
            setupPlayerMesh();
        },
        undefined,
        (err) => {
            console.warn("Không load được model, dùng hộp thay thế.");
            // Fallback: Dùng khối hộp màu vàng nếu không có model
            const geo = new THREE.BoxGeometry(TILE_SIZE*0.6, TILE_SIZE*0.6, TILE_SIZE*0.6);
            const mat = new THREE.MeshStandardMaterial({ color: 0xf1c40f });
            player = new THREE.Mesh(geo, mat);
            setupPlayerMesh();
        }
    );
}

function setupPlayerMesh() {
    player.scale.set(0.5, 0.5, 0.5); // Chỉnh scale nếu cần
    mazeGroup.add(player);
    // Đặt vị trí ban đầu tại ô (1,1)
    currentTile = { r: 1, c: 1 };
    updatePlayerPositionVisual(currentTile.r, currentTile.c);
}

function updatePlayerPositionVisual(r, c) {
    if(!player) return;
    const x = (c - COLS/2) * TILE_SIZE;
    const z = (r - ROWS/2) * TILE_SIZE;
    player.position.set(x, TILE_SIZE/2, z); // Nổi lên trên sàn một chút
}

// --- LOGIC GAME LOOP (QUAN TRỌNG) ---
function render() {
    const dt = clock.getDelta();
    if(isGameRunning && player) {
        updateMovement(dt);
    }
    renderer.render(scene, camera);
}

function updateMovement(dt) {
    // 1. Nếu đang đứng yên (IDLE) -> Kiểm tra xem có lệnh di chuyển không
    if (moveState === 'IDLE') {
        // Ưu tiên hướng mới (Input buffer)
        if (nextDir.r !== 0 || nextDir.c !== 0) {
            if (canMoveTo(currentTile.r + nextDir.r, currentTile.c + nextDir.c)) {
                currentDir = { ...nextDir };
                nextDir = { r:0, c:0 }; // Xóa buffer
                startMoving();
                return;
            }
        }
        // Nếu không rẽ được, tiếp tục đi hướng cũ
        if (currentDir.r !== 0 || currentDir.c !== 0) {
            if (canMoveTo(currentTile.r + currentDir.r, currentTile.c + currentDir.c)) {
                startMoving();
            } else {
                // Đụng tường -> Dừng hẳn
                currentDir = { r:0, c:0 };
            }
        }
    }

    // 2. Nếu đang di chuyển (MOVING) -> Lerp tới ô đích
    if (moveState === 'MOVING') {
        const destX = (targetTile.c - COLS/2) * TILE_SIZE;
        const destZ = (targetTile.r - ROWS/2) * TILE_SIZE;
        
        // Di chuyển Mesh
        const speed = MOVE_SPEED * dt;
        const targetVec = new THREE.Vector3(destX, TILE_SIZE/2, destZ);
        const dist = player.position.distanceTo(targetVec);

        if (dist < speed) {
            // Đã ĐẾN NƠI
            player.position.copy(targetVec);
            currentTile = { ...targetTile };
            moveState = 'IDLE';
            
            // Xoay nhân vật theo hướng đi (Optional)
            if (currentDir.r === 1) player.rotation.y = 0; // Xuống
            if (currentDir.r === -1) player.rotation.y = Math.PI; // Lên
            if (currentDir.c === 1) player.rotation.y = Math.PI/2; // Phải
            if (currentDir.c === -1) player.rotation.y = -Math.PI/2; // Trái
        } else {
            // Đang TRƯỢT
            const dirVec = new THREE.Vector3().subVectors(targetVec, player.position).normalize();
            player.position.addScaledVector(dirVec, speed);
        }
    }
}

function startMoving() {
    targetTile = { 
        r: currentTile.r + currentDir.r, 
        c: currentTile.c + currentDir.c 
    };
    moveState = 'MOVING';
}

function canMoveTo(r, c) {
    // Kiểm tra biên giới hạn
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
    // Kiểm tra tường (giá trị 1 là tường)
    if (grid[r][c] === 1) return false;
    return true;
}

// --- XỬ LÝ CẢM ỨNG (SWIPE) ---
function setupTouchControls() {
    let xDown = null;
    let yDown = null;

    window.addEventListener('touchstart', (evt) => {
        xDown = evt.touches[0].clientX;
        yDown = evt.touches[0].clientY;
    }, false);

    window.addEventListener('touchmove', (evt) => {
        if (!xDown || !yDown) return;
        
        let xUp = evt.touches[0].clientX;
        let yUp = evt.touches[0].clientY;
        let xDiff = xDown - xUp;
        let yDiff = yDown - yUp;

        // Nhận diện cú vuốt (Threshold > 10px)
        if (Math.abs(xDiff) > Math.abs(yDiff)) {
            if (Math.abs(xDiff) > 10) {
                // Vuốt Trái/Phải
                nextDir = xDiff > 0 ? { r:0, c:-1 } : { r:0, c:1 };
            }
        } else {
            if (Math.abs(yDiff) > 10) {
                // Vuốt Lên/Xuống (Lưu ý: Trong Grid 2D, r tăng là đi xuống)
                nextDir = yDiff > 0 ? { r:-1, c:0 } : { r:1, c:0 };
            }
        }
        // Reset để không bắt vuốt liên tục
        xDown = null; yDown = null;
    }, false);
}

// Hỗ trợ phím mũi tên cho PC
window.addEventListener('keydown', (e) => {
    if(e.key === "ArrowUp") nextDir = { r:-1, c:0 };
    if(e.key === "ArrowDown") nextDir = { r:1, c:0 };
    if(e.key === "ArrowLeft") nextDir = { r:0, c:-1 };
    if(e.key === "ArrowRight") nextDir = { r:0, c:1 };
});

// Hỗ trợ nút ảo trên màn hình
document.getElementById('btnUp').onclick = () => nextDir = { r:-1, c:0 };
document.getElementById('btnDown').onclick = () => nextDir = { r:1, c:0 };
document.getElementById('btnLeft').onclick = () => nextDir = { r:0, c:-1 };
document.getElementById('btnRight').onclick = () => nextDir = { r:0, c:1 };

</script>
</body>
</html>
#v1.0.6