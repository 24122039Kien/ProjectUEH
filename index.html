<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0"/>
<title>Hành Trình Linh Nghê - Final Timer</title>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<style>
  body { margin:0; overflow:hidden; font-family: sans-serif; user-select: none; -webkit-user-select: none; }
  
  /* UI CSS */
  #introScreen {
    position: fixed; inset: 0;
    background-image: url('Background.png'); 
    background-size: cover; background-position: center;
    background-color: #ffeaa7;
    display:flex; flex-direction:column;
    justify-content:center; align-items:center;
    z-index: 100;
  }
  
  #startARBtn {
    margin-top: -150px; 
    background: #FEF7E6; 
    color: #0E5C6C; 
    border: none; 
    box-shadow: none;
    padding: 15px 40px; 
    font-size: 22px; 
    font-weight: 900; 
    border-radius: 50px;
    cursor: pointer; z-index: 101; pointer-events: auto;
  }
  
  #startARBtn:active { 
    transform: scale(0.95); 
    opacity: 0.8;
  }

  .iconBtn {
    position: fixed; width:60px; height:60px;
    background: transparent; border:none;
    background-size: contain; background-repeat:no-repeat; background-position:center;
    z-index: 102; cursor:pointer;
  }
  #volumeBtn { top:20px; right:20px; background-image:url('Volume_on.png'); }
  #helpBtn { bottom:20px; right:20px; background-image:url('Help.png'); }

  .overlay-screen {
    position: fixed; inset: 0; background: rgba(0,0,0,0.9);
    display:none; flex-direction: column; justify-content:center; align-items:center;
    z-index: 200;
  }
  .overlay-screen img { max-width: 95%; max-height: 85%; object-fit: contain; margin-bottom: 20px; }
  .active { display: flex !important; }

  .home-btn {
    padding: 12px 30px; font-size: 18px; font-weight: bold;
    background: #e74c3c; color: white;
    border: 2px solid white; border-radius: 30px;
    cursor: pointer;
  }

  #game-ui {
    position: fixed; 
    top: 20%; 
    left: 0; 
    width: 100%; 
    text-align: center; 
    color: #ffaa00; 
    font-size: 24px; /* Chữ vừa phải */
    font-weight: 900; 
    font-family: sans-serif; 
    -webkit-text-stroke: 1px #5e3000; 
    text-shadow: 2px 2px 0px #5e3000;
    z-index: 90; 
    display: none; 
    pointer-events: none; 
  }
  
  #ar-guide {
    position: fixed; bottom: 50px; left:0; width:100%;
    text-align: center; color: yellow; font-size: 16px;
    text-shadow: 1px 1px 2px black; pointer-events: none;
    display: none; z-index: 999; font-weight: bold;
  }
  
  #error-console {
    position: fixed; top:0; left:0; width:100%; background:rgba(200,0,0,0.8);
    color:white; font-size:12px; pointer-events:none; z-index:99999; display:none;
  }
  
  #ar-overlay {
    position: fixed; 
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 80; 
    pointer-events: none; 
    background-image: url('Frame.png'); 
    background-size: cover; 
    background-position: center;
    background-repeat: no-repeat;
    display: none; 
  }
</style>
</head>

<body>

<div id="error-console"></div>
<div id="ar-guide">Quét sàn nhà để đặt Game...</div>

<div id="game-ui">
  Số ngọc đã thu thập:<br>
  <span id="scoreText" style="color: yellow; font-size: 1.3em;">0</span> / 10
  <div style="margin-top: 5px; font-size: 0.8em; color: white; -webkit-text-stroke: 0px;">
    ⏱ <span id="timeText">00:00</span>
  </div>
</div>

<div id="ar-overlay"></div>

<div id="introScreen">
  <button id="startARBtn" onclick="startGame()">Bắt đầu AR</button>
</div>

<button id="volumeBtn" class="iconBtn" onclick="toggleMute()"></button>
<button id="helpBtn" class="iconBtn" onclick="showHelp()"></button>

<div id="ruleScreen" class="overlay-screen" onclick="nextSlide()">
  <img id="ruleImage" src="LoiNgo.png" />
</div>

<div id="winScreen" class="overlay-screen">
  <img src="Win.png" alt="Chiến Thắng" />
  
  <div id="finalTime" style="color: #ffaa00; font-size: 24px; font-weight: 900; margin-bottom: 20px; text-shadow: 2px 2px 0 #5e3000;">
    Thời gian: 00:00
  </div>
  
  <button class="home-btn" onclick="location.reload()">Về Màn Hình Chính</button>
</div>

<script>
// Biến cờ kiểm tra
let isGameMode = false;

// Bắt lỗi hệ thống
window.onerror = function(msg, url, line) {
    const div = document.getElementById('error-console');
    if(div) {
        div.style.display = 'block';
        div.innerText = "LỖI: " + msg + " (Dòng " + line + ")";
    }
};

const ruleScreen = document.getElementById('ruleScreen');
const ruleImage = document.getElementById('ruleImage');
const introScreen = document.getElementById('introScreen');

// 1. NÚT HELP
function showHelp() {
    isGameMode = false; 
    ruleImage.src = "LoiNgo.png"; 
    ruleScreen.classList.add('active');
}

// 2. NÚT BẮT ĐẦU
function startGame() {
    bgMusic.play().catch(e=>{});
    introScreen.style.display = 'none';
    isGameMode = true; 
    ruleImage.src = "LuatChoi.png"; 
    ruleScreen.classList.add('active');
}

// 3. KHI NHẤN VÀO MÀN HÌNH
function nextSlide() {
    ruleScreen.classList.remove('active');
    if (isGameMode === true) {
      if (window.initARSession) {
          window.initARSession();
      } else {
          alert("Lỗi: Module AR chưa tải xong!");
          introScreen.style.display = 'flex'; 
      }
      isGameMode = false; 
    }
}

// LOGIC ÂM THANH
const bgMusic = new Audio("Audio.mp3");
bgMusic.loop = true;
let isMuted = false;

function toggleMute() {
    isMuted = !isMuted;
    bgMusic.muted = isMuted;
    document.getElementById('volumeBtn').style.opacity = isMuted ? "0.5" : "1";
    if(!isMuted) bgMusic.play().catch(e=>{});
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

let renderer, scene, camera;
let mazeGroup, player, reticle;
let hitTestSource = null, hitTestSourceRequested = false, isMazePlaced = false;
let grid = [], orbMeshes = [];

// --- BIẾN THỜI GIAN ---
let gameStartTime;
let gameTimerInterval;

// --- CẤU HÌNH ---
const ROWS = 15, COLS = 15;
const TILE_SIZE = 0.08; 
const TOTAL_ORBS = 10; 
// ----------------

let moveState='IDLE';
let currentTile={r:1, c:1}, targetTile={r:1, c:1};
let currentDir={r:0, c:0}, nextDir={r:0, c:0};

window.initARSession = async function() {
    if (!navigator.xr) { alert("Thiết bị không hỗ trợ AR"); return; }
    try {
        const session = await navigator.xr.requestSession('immersive-ar', { 
            requiredFeatures: ['local', 'hit-test'],
            optionalFeatures: ['dom-overlay'], 
            domOverlay: { root: document.body } 
        });
        setupThree(session);
    } catch (e) { alert("Lỗi mở AR: " + e.message); }
};

function setupThree(session) {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

    renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.xr.setSession(session);
    renderer.xr.setReferenceSpaceType('local');
    document.body.appendChild(renderer.domElement);

    // Hiện khung viền ngay lập tức
    document.getElementById('ar-overlay').style.display = 'block';

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5,10,5);
    scene.add(dirLight);

    reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    mazeGroup = new THREE.Group();
    mazeGroup.visible = false;
    scene.add(mazeGroup);

    createMazeDFS(); 
    spawnOrbs();
    loadPlayer();

    session.addEventListener('select', onSelect);
    document.getElementById('ar-guide').style.display = 'block';
    renderer.setAnimationLoop(render);
    setupTouch();
}

// HÀM ĐẾM GIỜ MỚI
function startGameTimer() {
    gameStartTime = Date.now();
    gameTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        
        // Cập nhật đồng hồ (không ảnh hưởng đến điểm số)
        const timeDom = document.getElementById('timeText');
        if(timeDom) timeDom.innerText = `${minutes}:${seconds}`;
    }, 1000);
}

function onSelect() {
    if (reticle.visible && !isMazePlaced) {
        mazeGroup.position.setFromMatrixPosition(reticle.matrix);
        mazeGroup.visible = true;
        isMazePlaced = true;
        reticle.visible = false;
        
        // Bắt đầu đếm giờ khi đặt game
        startGameTimer();
        
        document.getElementById('ar-guide').style.display = 'none';
        document.getElementById('game-ui').style.display = 'block'; 
    }
}

function render(timestamp, frame) {
    if (frame) {
        if (!isMazePlaced) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            const session = renderer.xr.getSession();
            if (!hitTestSourceRequested) {
                session.requestReferenceSpace('viewer').then((refSpace) => {
                    session.requestHitTestSource({ space: refSpace }).then((source) => { hitTestSource = source; });
                });
                session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; });
                hitTestSourceRequested = true;
            }
            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    reticle.visible = true;
                    reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    document.getElementById('ar-guide').innerText = "Chạm màn hình để đặt Game";
                } else {
                    reticle.visible = false;
                    document.getElementById('ar-guide').innerText = "Quét sàn nhà để đặt Game...";
                }
            }
        }
        if (isMazePlaced && player) {
            updatePlayerMovement();
            animateOrbs();
        }
    }
    renderer.render(scene, camera);
}

function createMazeDFS() {
    const wallColor = 0x5198A5; 
    const floorColor = 0x00598B; 

    const fGeo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
    const fMat = new THREE.MeshBasicMaterial({color: floorColor, transparent:true, opacity:0.9});
    const wGeo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
    const wMat = new THREE.MeshStandardMaterial({color: wallColor});

    grid = Array.from({length: ROWS}, () => Array(COLS).fill(1));

    const dirs = [[0,2], [0,-2], [2,0], [-2,0]]; 
    function carve(r, c) {
        grid[r][c] = 0;
        dirs.sort(() => Math.random() - 0.5);
        for (let [dr, dc] of dirs) {
            let nr = r + dr, nc = c + dc;
            if (nr > 0 && nr < ROWS-1 && nc > 0 && nc < COLS-1 && grid[nr][nc] === 1) {
                grid[r + dr/2][c + dc/2] = 0; 
                carve(nr, nc);
            }
        }
    }
    carve(1, 1);

    for(let i=0; i<15; i++){
        let r = Math.floor(Math.random()*(ROWS-2))+1;
        let c = Math.floor(Math.random()*(COLS-2))+1;
        grid[r][c] = 0;
    }

    for(let r=0; r<ROWS; r++){
        for(let c=0; c<COLS; c++){
            let x = (c - COLS/2) * TILE_SIZE;
            let z = (r - ROWS/2) * TILE_SIZE;
            if(grid[r][c] === 1){ 
                let m = new THREE.Mesh(wGeo, wMat);
                m.position.set(x, TILE_SIZE/2, z); 
                mazeGroup.add(m);
            } else { 
                let f = new THREE.Mesh(fGeo, fMat);
                f.rotation.x = -Math.PI/2;
                f.position.set(x, 0.005, z);
                mazeGroup.add(f);
            }
        }
    }
}

function spawnOrbs() {
    const orbGeo = new THREE.SphereGeometry(TILE_SIZE * 0.25, 16, 16);
    const orbMat = new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0xaa6600});

    let count = 0;
    let attempts = 0;
    while(count < TOTAL_ORBS && attempts < 2000){
        attempts++;
        let r = Math.floor(Math.random() * (ROWS-2)) + 1;
        let c = Math.floor(Math.random() * (COLS-2)) + 1;
        
        if(grid[r][c] === 0 && !(r==1 && c==1)) {
            const exists = orbMeshes.find(o => o.userData.r === r && o.userData.c === c);
            if(!exists){
                let orb = new THREE.Mesh(orbGeo, orbMat);
                let x = (c - COLS/2) * TILE_SIZE;
                let z = (r - ROWS/2) * TILE_SIZE;
                orb.position.set(x, TILE_SIZE * 0.3, z);
                orb.userData = { r: r, c: c, active: true };
                mazeGroup.add(orb);
                orbMeshes.push(orb);
                count++;
            }
        }
    }
}

function animateOrbs() {
    const time = Date.now() * 0.002;
    orbMeshes.forEach(orb => {
        if(orb.userData.active) {
            orb.position.y = (TILE_SIZE * 0.3) + Math.sin(time) * 0.01;
            orb.rotation.y += 0.05;
        }
    });
}

function checkCollection() {
    orbMeshes.forEach(orb => {
        if (orb.userData.active && orb.userData.r === currentTile.r && orb.userData.c === currentTile.c) {
            orb.userData.active = false;
            orb.visible = false;
            let collected = orbMeshes.filter(o => !o.userData.active).length;
            
            // CẬP NHẬT ĐIỂM SỐ (Chỉ update phần số)
            const scoreDom = document.getElementById('scoreText');
            if(scoreDom) scoreDom.innerText = collected;
            
            if(collected >= TOTAL_ORBS) {
                // DỪNG ĐỒNG HỒ & HIỆN KẾT QUẢ
                clearInterval(gameTimerInterval);
                const finalTimeStr = document.getElementById('timeText').innerText;
                document.getElementById('finalTime').innerText = `Thành tích: ${finalTimeStr}`;

                setTimeout(() => {
                    document.getElementById('winScreen').classList.add('active');
                    document.getElementById('game-ui').style.display = 'none';
                    renderer.xr.getSession().end();
                }, 500);
            }
        }
    });
}

function loadPlayer() {
    const loader = new GLTFLoader();
    loader.load('model.glb', (gltf)=>{
        const playerContainer = new THREE.Group();
        const model = gltf.scene;

        model.traverse((node) => { if (node.isMesh) node.castShadow = true; });

        // Số 0: Mặc định
        // Số 1: Xoay 90 độ (Nếu đang đi ngang sang Phải)
        // Số 2: Xoay 180 độ (Nếu đang đi lùi / Moonwalk)
        // Số 3: Xoay -90 độ (Nếu đang đi ngang sang Trái)
        
        const TRUONG_HOP = 1; // <--- Thay số 0, 1, 2, hoặc 3 vào đây
        
        // ==============================================================

        // Logic xử lý xoay tự động dựa trên số bạn chọn
        model.rotation.set(0, 0, 0); // Reset trước
        
        if (TRUONG_HOP === 1) model.rotation.y = Math.PI / 2;
        else if (TRUONG_HOP === 2) model.rotation.y = Math.PI;
        else if (TRUONG_HOP === 3) model.rotation.y = -Math.PI / 2;
        // Nếu là 0 thì giữ nguyên rotation.y = 0

        // Fix lỗi nằm (nếu model của bạn bị nằm sấp thì mở dòng dưới ra)
        // model.rotation.x = Math.PI / 2; 

        model.position.set(0, 0, 0); 
        playerContainer.add(model);
        player = playerContainer;

        const scale = TILE_SIZE * 0.7; 
        player.scale.set(scale, scale, scale); 
        
        mazeGroup.add(player);
        updatePlayerVisualPos();
    }, undefined, (e)=>{
        console.error(e);
        // Fallback
        player = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE*0.6, TILE_SIZE*0.6, TILE_SIZE*0.6), new THREE.MeshStandardMaterial({color:'red'}));
        mazeGroup.add(player);
        updatePlayerVisualPos();
    });
}

function updatePlayerVisualPos(){
    if(!player) return;
    let x = (currentTile.c - COLS/2) * TILE_SIZE;
    let z = (currentTile.r - ROWS/2) * TILE_SIZE;
    player.position.set(x, 0, z);
}

function updatePlayerMovement() {
    if (!player) return;

    if(moveState === 'MOVING') {
        let destX = (targetTile.c - COLS/2)*TILE_SIZE;
        let destZ = (targetTile.r - ROWS/2)*TILE_SIZE;
        let targetPos = new THREE.Vector3(destX, 0, destZ);
        
        const speed = TILE_SIZE * 0.15; 

        // LỆNH NÀY SẼ BẮT MODEL XOAY THEO HƯỚNG ĐI
        player.lookAt(destX, player.position.y, destZ);

        if(player.position.distanceTo(targetPos) < speed) {
            player.position.copy(targetPos);
            currentTile = {...targetTile};
            moveState = 'IDLE';
            checkCollection();
        } else {
            let dir = new THREE.Vector3().subVectors(targetPos, player.position).normalize();
            player.position.addScaledVector(dir, speed);
        }

    } else if(moveState === 'IDLE') {
        if(nextDir.r !== 0 || nextDir.c !== 0) {
            let nr = currentTile.r + nextDir.r;
            let nc = currentTile.c + nextDir.c;
            if(grid[nr] && grid[nr][nc] === 0) {
                targetTile = {r: nr, c: nc};
                moveState = 'MOVING';
                
                // XOAY NGAY LẬP TỨC KHI VUỐT
                let destX = (nc - COLS/2)*TILE_SIZE;
                let destZ = (nr - ROWS/2)*TILE_SIZE;
                player.lookAt(destX, player.position.y, destZ);
            }
            nextDir = {r:0, c:0};
        }
    }
}

function setupTouch() {
    let startX, startY;
    window.addEventListener('touchstart', e=>{
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
    });
    window.addEventListener('touchend', e=>{
        if(!isMazePlaced) return;
        let dx = e.changedTouches[0].clientX - startX;
        let dy = e.changedTouches[0].clientY - startY;
        if(Math.abs(dx) > Math.abs(dy)) nextDir = dx>0 ? {r:0,c:1} : {r:0,c:-1};
        else nextDir = dy>0 ? {r:1,c:0} : {r:-1,c:0};
    });
}
</script>
</body>
</html>
#v1.0.21